/**
 * Concrete implementation of BaseMarkdownExporter specifically for GitHub Copilot chat sessions
 * Provides GitHub Copilot-specific header and footer formatting
 */

import { BaseMarkdownExporter } from './BaseMarkdownExporter';
import { MarkdownFormatter, ExportOptions } from './types';

/**
 * GitHub Copilot-specific markdown exporter
 * Formats chat sessions with appropriate branding and structure for Copilot conversations
 */
export class GitHubCopilotExporter extends BaseMarkdownExporter {

  /**
   * Initialize the GitHub Copilot exporter
   * @param formatter The markdown formatter to use
   * @param options Export configuration options
   */
  constructor(formatter: MarkdownFormatter, options: ExportOptions = {}) {
    super(formatter, options);
  }

  /**
   * Format the document header with GitHub Copilot branding
   * @returns Formatted header string with title and description
   */
  formatHeader(): string {
    const sections = [
      '# GitHub Copilot Chat Session',
      '',
      'This document contains a conversation with GitHub Copilot, an AI-powered coding assistant.',
      'The session has been exported for reference and documentation purposes.',
      '',
      '> **Note**: This export was generated by the Socrates VS Code Extension',
      '> for preserving and organizing GitHub Copilot chat history.',
    ];

    return sections.join('\n');
  }

  /**
   * Format the document footer with export information and branding
   * @returns Formatted footer string with export details
   */
  formatFooter(): string {
    const exportTime = new Date().toLocaleString();

    const sections = [
      '## Export Information',
      '',
      `- **Exported at**: ${exportTime}`,
      '- **Exported by**: [Socrates VS Code Extension](https://github.com/your-repo/socrates)',
      '- **Format**: Markdown',
      '- **Source**: GitHub Copilot Chat',
      '',
      '---',
      '',
      '*This document was automatically generated from GitHub Copilot chat history.*',
      '*For more information about the Socrates extension, visit our documentation.*',
    ];

    return sections.join('\n');
  }

  /**
   * Override the template method to add Copilot-specific processing
   * @param session The chat session to export
   * @returns Export result with Copilot-specific formatting
   */
  export(session: any) {
    // Add Copilot-specific metadata to options if not already set
    const copilotOptions = {
      ...this.options,
      includeMetadata: this.options.includeMetadata ?? true,
      includeTimestamps: this.options.includeTimestamps ?? true,
    };

    // Temporarily update options for this export
    const originalOptions = this.options;
    this.options = copilotOptions;

    try {
      // Call the parent export method
      const result = super.export(session);

      // Add Copilot-specific metadata to the result
      if (result.success && result.content) {
        result.content = this.addCopilotMetadata(result.content, session);
      }

      return result;
    } finally {
      // Restore original options
      this.options = originalOptions;
    }
  }

  /**
   * Add GitHub Copilot-specific metadata to the exported content
   * @param content The base exported content
   * @param session The original session data
   * @returns Enhanced content with Copilot metadata
   */
  private addCopilotMetadata(content: string, session: any): string {
    // Insert Copilot-specific metadata after the header
    const headerEnd = content.indexOf('\n---\n');
    if (headerEnd === -1) return content;

    const copilotMetadata = this.formatCopilotMetadata(session);
    const beforeMetadata = content.substring(0, headerEnd);
    const afterMetadata = content.substring(headerEnd);

    return `${beforeMetadata}\n\n${copilotMetadata}${afterMetadata}`;
  }

  /**
   * Format GitHub Copilot-specific metadata
   * @param session The chat session
   * @returns Formatted Copilot metadata section
   */
  private formatCopilotMetadata(session: any): string {
    const sections = [
      '## GitHub Copilot Context',
      '',
      '- **AI Model**: GitHub Copilot',
      '- **Interaction Type**: Chat Session',
      '- **Capabilities**: Code generation, explanation, debugging, and general programming assistance',
    ];

    // Add session-specific context if available
    if (session.metadata?.title) {
      sections.push(`- **Session Topic**: ${session.metadata.title}`);
    }

    // Add programming language context if detectable
    const languages = this.detectProgrammingLanguages(session);
    if (languages.length > 0) {
      sections.push(`- **Languages Discussed**: ${languages.join(', ')}`);
    }

    return sections.join('\n');
  }

  /**
   * Detect programming languages mentioned in the session
   * @param session The chat session
   * @returns Array of detected programming languages
   */
  private detectProgrammingLanguages(session: any): string[] {
    const languages = new Set<string>();
    const languagePatterns = [
      /```(\w+)/g,  // Code blocks with language
      /\b(javascript|typescript|python|java|c\+\+|c#|ruby|go|rust|php|swift|kotlin)\b/gi,
    ];

    // Check all message content for language indicators
    session.messages?.forEach((message: any) => {
      if (typeof message.content === 'string') {
        languagePatterns.forEach(pattern => {
          const matches = message.content.matchAll(pattern);
          for (const match of matches) {
            if (match[1]) {
              languages.add(match[1].toLowerCase());
            }
          }
        });
      }
    });

    return Array.from(languages).sort();
  }
}
